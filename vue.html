<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | Away的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/1.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.a0346aa4.css" as="style"><link rel="preload" href="/assets/js/app.ec2b46c2.js" as="script"><link rel="preload" href="/assets/js/2.ffba0665.js" as="script"><link rel="preload" href="/assets/js/14.0582991d.js" as="script"><link rel="prefetch" href="/assets/js/10.86e25d52.js"><link rel="prefetch" href="/assets/js/11.311e2bb2.js"><link rel="prefetch" href="/assets/js/12.626cdf04.js"><link rel="prefetch" href="/assets/js/13.da24cdfa.js"><link rel="prefetch" href="/assets/js/3.c24b996f.js"><link rel="prefetch" href="/assets/js/4.ee876671.js"><link rel="prefetch" href="/assets/js/5.63f6f8b9.js"><link rel="prefetch" href="/assets/js/6.f12b0ad0.js"><link rel="prefetch" href="/assets/js/7.c5d01d95.js"><link rel="prefetch" href="/assets/js/8.1be552b7.js"><link rel="prefetch" href="/assets/js/9.db3f299c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a0346aa4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/1.jpg" alt="Away的博客" class="logo"> <span class="site-name can-hide">Away的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/basics.html" class="nav-link">
  基础篇
</a></div><div class="nav-item"><a href="/advanced.html" class="nav-link">
  进阶篇
</a></div><div class="nav-item"><a href="/top.html" class="nav-link">
  高级篇
</a></div><div class="nav-item"><a href="/jian.html" class="nav-link">
  精简篇
</a></div><div class="nav-item"><a href="/advanced.html" class="nav-link">
  进阶篇
</a></div><div class="nav-item"><a href="/vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue
</a></div><div class="nav-item"><a href="/react.html" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/others.html" class="nav-link">
  其它
</a></div><div class="nav-item"><a href="https://blog.csdn.net/fyc_away" target="_blank" rel="noopener noreferrer" class="nav-link external">
  csdn博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/fyc-Away" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/basics.html" class="nav-link">
  基础篇
</a></div><div class="nav-item"><a href="/advanced.html" class="nav-link">
  进阶篇
</a></div><div class="nav-item"><a href="/top.html" class="nav-link">
  高级篇
</a></div><div class="nav-item"><a href="/jian.html" class="nav-link">
  精简篇
</a></div><div class="nav-item"><a href="/advanced.html" class="nav-link">
  进阶篇
</a></div><div class="nav-item"><a href="/vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue
</a></div><div class="nav-item"><a href="/react.html" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/others.html" class="nav-link">
  其它
</a></div><div class="nav-item"><a href="https://blog.csdn.net/fyc_away" target="_blank" rel="noopener noreferrer" class="nav-link external">
  csdn博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/fyc-Away" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue.html#vue" class="sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue.html#聊聊对vue的理解" class="sidebar-link">聊聊对vue的理解</a></li><li class="sidebar-sub-header"><a href="/vue.html#v-model的是什么？" class="sidebar-link">V-model的是什么？</a></li><li class="sidebar-sub-header"><a href="/vue.html#谈谈对生命周期的理解" class="sidebar-link">谈谈对生命周期的理解</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue和react有什么区别？" class="sidebar-link">VUE和REACT有什么区别？</a></li><li class="sidebar-sub-header"><a href="/vue.html#vuex的流程" class="sidebar-link">vuex的流程</a></li><li class="sidebar-sub-header"><a href="/vue.html#vuex有哪几种状态和属性" class="sidebar-link">vuex有哪几种状态和属性</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue路由的两种模式" class="sidebar-link">vue路由的两种模式</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue中-key-值的作用" class="sidebar-link">vue中 key 值的作用</a></li><li class="sidebar-sub-header"><a href="/vue.html#route和-router的区别" class="sidebar-link">$route和$router的区别</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue-router守卫" class="sidebar-link">vue-router守卫</a></li><li class="sidebar-sub-header"><a href="/vue.html#axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="sidebar-link">axios是什么？怎么使用？描述使用它实现登录功能的流程？</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue修饰符" class="sidebar-link">vue修饰符</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue项目中的性能优化" class="sidebar-link">vue项目中的性能优化</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue-extend和vue-component" class="sidebar-link">vue.extend和vue.component</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue组件间的参数传递" class="sidebar-link">Vue组件间的参数传递</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue的路由实现：hash模式-和-history模式" class="sidebar-link">Vue的路由实现：hash模式 和 history模式</a></li><li class="sidebar-sub-header"><a href="/vue.html#v-if-和-v-show-区别" class="sidebar-link">v-if 和 v-show 区别</a></li><li class="sidebar-sub-header"><a href="/vue.html#keep-alive的作用是什么" class="sidebar-link">keep-alive的作用是什么</a></li><li class="sidebar-sub-header"><a href="/vue.html#指令v-el的作用是什么" class="sidebar-link">指令v-el的作用是什么</a></li><li class="sidebar-sub-header"><a href="/vue.html#在vue中使用插件的步骤" class="sidebar-link">在Vue中使用插件的步骤</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue的优点是什么？" class="sidebar-link">vue的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/vue.html#路由之间跳转？" class="sidebar-link">路由之间跳转？</a></li><li class="sidebar-sub-header"><a href="/vue.html#vue-组件-data-为什么必须是函数" class="sidebar-link">Vue 组件 data 为什么必须是函数</a></li><li class="sidebar-sub-header"><a href="/vue.html#怎么快速定位哪个组件出现性能问题" class="sidebar-link">怎么快速定位哪个组件出现性能问题</a></li><li class="sidebar-sub-header"><a href="/vue.html#extend-能做什么" class="sidebar-link">extend 能做什么</a></li><li class="sidebar-sub-header"><a href="/vue.html#mixin-和-mixins-区别" class="sidebar-link">mixin 和 mixins 区别</a></li><li class="sidebar-sub-header"><a href="/vue.html#computed-和-watch-区别" class="sidebar-link">computed 和 watch 区别</a></li><li class="sidebar-sub-header"><a href="/vue.html#proxy-相比于-defineproperty-的优势" class="sidebar-link">Proxy 相比于 defineProperty 的优势</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue"><a href="#vue" class="header-anchor">#</a> vue</h2> <h3 id="聊聊对vue的理解"><a href="#聊聊对vue的理解" class="header-anchor">#</a> 聊聊对vue的理解</h3> <blockquote><p>vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p></blockquote> <h3 id="v-model的是什么？"><a href="#v-model的是什么？" class="header-anchor">#</a> V-model的是什么？</h3> <blockquote><p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事</p> <ul><li>通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li></ul></blockquote> <h3 id="谈谈对生命周期的理解"><a href="#谈谈对生命周期的理解" class="header-anchor">#</a> 谈谈对生命周期的理解</h3> <ul><li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li> <li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li> <li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li> <li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li> <li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li> <li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li> <li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li> <li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul> <h3 id="vue和react有什么区别？"><a href="#vue和react有什么区别？" class="header-anchor">#</a> VUE和REACT有什么区别？</h3> <blockquote><p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p></blockquote> <blockquote><p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p></blockquote> <h3 id="vuex的流程"><a href="#vuex的流程" class="header-anchor">#</a> vuex的流程</h3> <div class="language- extra-class"><pre class="language-text"><code>页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。
mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中
通过mapGetter来动态获取state中的值

</code></pre></div><h3 id="vuex有哪几种状态和属性"><a href="#vuex有哪几种状态和属性" class="header-anchor">#</a> vuex有哪几种状态和属性</h3> <blockquote><ul><li>state中保存着共有数据，数据是响应式的</li> <li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li> <li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li> <li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li> <li>modules：模块化vuex</li></ul></blockquote> <h3 id="vue路由的两种模式"><a href="#vue路由的两种模式" class="header-anchor">#</a> vue路由的两种模式</h3> <blockquote><ul><li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li> <li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li></ul> <p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p></blockquote> <h3 id="vue中-key-值的作用"><a href="#vue中-key-值的作用" class="header-anchor">#</a> vue中 key 值的作用</h3> <blockquote><p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p></blockquote> <blockquote><p>key的作用主要是为了高效的更新虚拟DOM。</p></blockquote> <h3 id="route和-router的区别"><a href="#route和-router的区别" class="header-anchor">#</a> <code>$route</code>和<code>$router</code>的区别</h3> <blockquote><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li> <li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul></blockquote> <h3 id="vue-router守卫"><a href="#vue-router守卫" class="header-anchor">#</a> vue-router守卫</h3> <blockquote><ul><li>导航守卫 router.beforeEach 全局前置守卫</li></ul></blockquote> <ul><li>to: Route: 即将要进入的目标（路由对象）</li> <li>from: Route: 当前导航正要离开的路由</li> <li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。</li> <li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li> <li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// main.js 入口文件
    import router from './router'; // 引入路由
    router.beforeEach((to, from, next) =&gt; { 
      next();
    });
    router.beforeResolve((to, from, next) =&gt; {
      next();
    });
    router.afterEach((to, from) =&gt; {
      console.log('afterEach 全局后置钩子');
    });


</code></pre></div><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]
})

</code></pre></div><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p> <div class="language- extra-class"><pre class="language-text"><code>const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}

</code></pre></div><h3 id="axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="header-anchor">#</a> axios是什么？怎么使用？描述使用它实现登录功能的流程？</h3> <blockquote><p>请求后台资源的模块。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>$ npm install axios -S装好

</code></pre></div><blockquote><p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。 js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p></blockquote> <h3 id="vue修饰符"><a href="#vue修饰符" class="header-anchor">#</a> vue修饰符</h3> <ul><li>stop：阻止事件的冒泡</li> <li>prevent：阻止事件的默认行为</li> <li>once：只触发一次</li> <li>self：只触发自己的事件行为时，才会执行</li></ul> <h3 id="vue项目中的性能优化"><a href="#vue项目中的性能优化" class="header-anchor">#</a> vue项目中的性能优化</h3> <blockquote><p>1.不要在模板里面写过多表达式</p></blockquote> <blockquote><p>2.循环调用子组件时添加key</p></blockquote> <blockquote><p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p></blockquote> <blockquote><p>4.尽量少用float，可以用flex</p></blockquote> <blockquote><p>5.按需加载，可以用require或者import()按需加载需要的组件</p></blockquote> <blockquote><p>6.路由懒加载</p></blockquote> <h3 id="vue-extend和vue-component"><a href="#vue-extend和vue-component" class="header-anchor">#</a> vue.extend和vue.component</h3> <blockquote><ul><li>extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li> <li>Vue.component 你可以创建 ，也可以取组件。</li></ul></blockquote> <h3 id="vue组件间的参数传递"><a href="#vue组件间的参数传递" class="header-anchor">#</a> Vue组件间的参数传递</h3> <p><strong>父组件与子组件传值</strong></p> <blockquote><p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p></blockquote> <ul><li>子组件传给父组件： <code>$emit</code> 方法传递参数</li></ul> <p><strong>非父子组件间的数据传递，兄弟组件传值</strong></p> <blockquote><p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用<code>VUEX</code>，具体来说看需求）</p></blockquote> <h3 id="vue的路由实现：hash模式-和-history模式"><a href="#vue的路由实现：hash模式-和-history模式" class="header-anchor">#</a> Vue的路由实现：hash模式 和 history模式</h3> <ul><li><code>hash</code>模式：在浏览器中符号<code>“#”</code>，#以及#后面的字符称之为<code>hash</code>，用 <code>window.location.hash</code> 读取。特点：<code>hash</code>虽然在<code>URL</code>中，但不被包括在<code>HTTP</code>请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。</li> <li><code>history</code>模式：h<code>istory</code>采用<code>HTML5</code>的新特性；且提供了两个新方法： <code>pushState()</code>， <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更</li></ul> <h3 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="header-anchor">#</a> v-if 和 v-show 区别</h3> <ul><li><code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code></li></ul> <h3 id="keep-alive的作用是什么"><a href="#keep-alive的作用是什么" class="header-anchor">#</a> <code>keep-alive</code>的作用是什么</h3> <ul><li>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染</li></ul> <blockquote><p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用``进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p></blockquote> <h3 id="指令v-el的作用是什么"><a href="#指令v-el的作用是什么" class="header-anchor">#</a> 指令v-el的作用是什么</h3> <blockquote><p>提供一个在页面上已存在的 <code>DOM</code>元素作为 <code>Vue</code>实例的挂载目标.可以是 CSS 选择器，也可以是一个 <code>HTMLElement</code> 实例,</p></blockquote> <h3 id="在vue中使用插件的步骤"><a href="#在vue中使用插件的步骤" class="header-anchor">#</a> 在Vue中使用插件的步骤</h3> <ul><li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li> <li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, { someOption: true })</code></li></ul> <h3 id="vue的优点是什么？"><a href="#vue的优点是什么？" class="header-anchor">#</a> vue的优点是什么？</h3> <ul><li>低耦合。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>ViewModel</code>可以绑定到不同的<code>&quot;View&quot;</code>上，当View变化的时候Model可以不变，当<code>Model</code>变化的时候<code>View</code>也可以不变</li> <li>可重用性。你可以把一些视图逻辑放在一个<code>ViewModel</code>里面，让很多<code>view</code>重用这段视图逻辑</li> <li>可测试。界面素来是比较难于测试的，而现在测试可以针对<code>ViewModel</code>来写</li></ul> <h3 id="路由之间跳转？"><a href="#路由之间跳转？" class="header-anchor">#</a> 路由之间跳转？</h3> <p><strong>声明式（标签跳转）</strong></p> <div class="language-text extra-class"><pre class="language-text"><code>&lt;router-link :to=&quot;index&quot;&gt;
</code></pre></div><p><strong>编程式（ js跳转）</strong></p> <div class="language-text extra-class"><pre class="language-text"><code>router.push('index')
</code></pre></div><ul><li></li></ul> <h3 id="vue-组件-data-为什么必须是函数"><a href="#vue-组件-data-为什么必须是函数" class="header-anchor">#</a> Vue 组件 data 为什么必须是函数</h3> <ul><li>每个组件都是 <code>Vue</code> 的实例。</li> <li>组件共享 <code>data</code> 属性，当 <code>data</code> 的值是同一个引用类型的值时，改变其中一个会影响其他</li> <li></li></ul> <h3 id="怎么快速定位哪个组件出现性能问题"><a href="#怎么快速定位哪个组件出现性能问题" class="header-anchor">#</a> 怎么快速定位哪个组件出现性能问题</h3> <blockquote><p>用 <code>timeline</code> 工具。 大意是通过 <code>timeline</code> 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote> <h3 id="extend-能做什么"><a href="#extend-能做什么" class="header-anchor">#</a> extend 能做什么</h3> <blockquote><p>这个 <code>API</code> 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建组件构造器</span>
<span class="token keyword">let</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token string">'&lt;div&gt;test&lt;/div&gt;'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 挂载到 #app 上</span>
<span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token comment">// 除了上面的方式，还可以用来扩展已有的组件</span>
<span class="token keyword">let</span> SuperComponent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="header-anchor">#</a> mixin 和 mixins 区别</h3> <blockquote><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...逻辑</span>
        <span class="token comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>虽然文档不建议我们在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</li> <li><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</li> <li>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档。</li></ul> <h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="header-anchor">#</a> computed 和 watch 区别</h3> <ul><li><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</li> <li><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li> <li>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</li> <li>另外 <code>computer</code> 和 <code>watch</code> 还都支持对象的写法，这种方式知道的人并不多。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'obj'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 深度遍历</span>
    deep<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 立即触发</span>
    immediate<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 执行的函数</span>
    <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    aPlus<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// this.aPlus 时触发</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment">// this.aPlus = 1 时触发</span>
      <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> v <span class="token operator">-</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>


</code></pre></div><h3 id="proxy-相比于-defineproperty-的优势"><a href="#proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> Proxy 相比于 defineProperty 的优势</h3> <ul><li>数组变化也能监听到</li> <li>不需要深度遍历监听</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> reactiveData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><hr></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2b46c2.js" defer></script><script src="/assets/js/2.ffba0665.js" defer></script><script src="/assets/js/14.0582991d.js" defer></script>
  </body>
</html>
